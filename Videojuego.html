<!doctype html>
<html lang="es">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Juego isométrico - Demo</title>
	<style>
		html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
		body{display:flex;flex-direction:column;align-items:center;gap:8px;background:#0b1220;color:#e6eef8}
		h1{margin:12px 0 0 0;font-size:18px}
		#game{background:linear-gradient(#6089a6,#39586f);border:4px solid #0f1724;box-shadow:0 6px 18px rgba(0,0,0,.6)}
		footer{font-size:13px;opacity:.9}
		.hint{max-width:920px;text-align:center}
		@media (max-width:640px){h1{font-size:16px}}
	</style>
</head>
<body>
	<div style="display:flex;justify-content:space-between;align-items:center;width:100%;max-width:1000px;margin:0 auto;padding:0 20px;box-sizing:border-box">
		<h1>Juego isométrico (demo)</h1>
		<button id="resetGameBtn" style="padding:8px 12px;background:#c74444;border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:13px;">Reset</button>
	</div>
	<canvas id="game" width="960" height="640"></canvas>
	<div class="hint">Controles: Flechas o WASD — mueve al personaje en la cuadrícula isométrica. Se carga el sprite: <code>150-1505063_link-link-to-the-past-link-sprites.png</code></div>

	<!-- Selection overlay (appears before the game starts) -->
	<div id="selectScreen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(rgba(3,6,10,0.85),rgba(3,6,10,0.95));z-index:80;">
		<div style="background:#071021;padding:18px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.6);display:flex;gap:18px;align-items:center;">
			<div style="text-align:center;color:#e6eef8">
				<div style="font-weight:600;margin-bottom:8px">Elige tu personaje</div>
				<img id="optA" src="DBL15-06S.webp" alt="Opción A" style="width:140px;height:auto;border:3px solid #204;display:block;margin-bottom:8px;border-radius:6px;">
				<button id="chooseA" style="padding:8px 12px;border-radius:6px;">Elegir A</button>
			</div>
			<div style="width:1px;background:rgba(255,255,255,0.06);height:160px"></div>
			<div style="text-align:center;color:#e6eef8">
				<div style="font-weight:600;margin-bottom:8px">Elige tu rival</div>
				<img id="optB" src="DBL-EVT-19S.webp" alt="Opción B" style="width:140px;height:auto;border:3px solid #420;display:block;margin-bottom:8px;border-radius:6px;">
				<button id="chooseB" style="padding:8px 12px;border-radius:6px;">Elegir B</button>
			</div>
		</div>
	</div>

	<!-- Intro screen showing rival above and player below (briefly after selection) -->
	<div id="introScreen" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(rgba(2,4,6,0.9),rgba(2,4,6,0.95));z-index:85;">
		<div style="width:520px;height:360px;background:linear-gradient(#081826,#07202a);border-radius:10px;padding:18px;display:flex;flex-direction:column;align-items:center;justify-content:space-between;color:#e6eef8">
			<div id="rivalPreview" style="margin-top:8px;"></div>
			<div style="height:40px;display:flex;align-items:center;justify-content:center;color:#9fb4c6">VS</div>
			<div id="playerPreview" style="margin-bottom:8px;"></div>
			<div style="font-size:13px;color:#8aa0b0">Preparando partida...</div>
		</div>
	</div>
	<footer>Este es un prototipo: puedes mejorar las animaciones, colisiones y tiles usando la hoja de sprites en la carpeta del proyecto.</footer>

	<script>
	// Config
	const canvas = document.getElementById('game');
	const ctx = canvas.getContext('2d');

	function fitCanvas(){
		// keep aspect and fit
		const maxW = Math.min(window.innerWidth - 40, 1200);
		const maxH = Math.min(window.innerHeight - 160, 800);
		canvas.width = maxW;
		canvas.height = maxH;
	}
	window.addEventListener('resize', fitCanvas);
	fitCanvas();

	// Assets
	const SPRITE_SRC = 'images.png';
	const sprite = new Image();
	sprite.src = SPRITE_SRC;
	let spriteLoaded = false;
	sprite.onload = () => { spriteLoaded = true; };

	// If the user chose a character in the selector, use that image instead
	let selectedCharSrc = null;
	let charImg = null;
	let charLoaded = false;
	try{
		selectedCharSrc = localStorage.getItem('juegodbl_character');
	}catch(e){ selectedCharSrc = null; }
	if (selectedCharSrc){
		charImg = new Image();
		charImg.src = selectedCharSrc;
		charImg.onload = () => { charLoaded = true; };
		charImg.onerror = () => { charLoaded = false; console.warn('No se pudo cargar la imagen seleccionada:', selectedCharSrc); };
	}

	// Sprite sheet frame definitions (images.png - 355x142)
	// Frames de 32x32 con escudo - 4 filas (down, right, left, up) x 11 columnas
	const FRAME_W = 32;
	const FRAME_H = 32;
	
	const frames = {
		down: [
			{x: 0, y: 0, w: FRAME_W, h: FRAME_H},
			{x: 32, y: 0, w: FRAME_W, h: FRAME_H},
			{x: 64, y: 0, w: FRAME_W, h: FRAME_H}
		],
		right: [
			{x: 0, y: 32, w: FRAME_W, h: FRAME_H},
			{x: 32, y: 32, w: FRAME_W, h: FRAME_H},
			{x: 64, y: 32, w: FRAME_W, h: FRAME_H}
		],
		left: [
			{x: 0, y: 64, w: FRAME_W, h: FRAME_H},
			{x: 32, y: 64, w: FRAME_W, h: FRAME_H},
			{x: 64, y: 64, w: FRAME_W, h: FRAME_H}
		],
		up: [
			{x: 0, y: 96, w: FRAME_W, h: FRAME_H},
			{x: 32, y: 96, w: FRAME_W, h: FRAME_H},
			{x: 64, y: 96, w: FRAME_W, h: FRAME_H}
		]
	};

	// Map & camera
	const MAP_W = 20;
	const MAP_H = 20;
	const TILE_W = 64; // tile width in pixels
	const TILE_H = 32; // tile height in pixels (vertical)

	let cam = {x: Math.floor(MAP_W/2), y: Math.floor(MAP_H/2)}; // camera focus in tile coords

	// Player in tile coords
	const player = {
		x: Math.floor(MAP_W/2),
		y: Math.floor(MAP_H/2),
		speed: 6,
		direction: 'down',
		animFrame: 0,
		animTime: 0,
		animSpeed: 0.15
	};

	// keyboard
	const keys = {};
	window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
	window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

	function worldToScreen(wx, wy){
		const sx = (wx - wy) * (TILE_W/2);
		const sy = (wx + wy) * (TILE_H/2);
		return {x: sx, y: sy};
	}

	function drawDiamond(x, y, fillStyle){
		ctx.beginPath();
		ctx.moveTo(x, y - TILE_H/2);
		ctx.lineTo(x + TILE_W/2, y);
		ctx.lineTo(x, y + TILE_H/2);
		ctx.lineTo(x - TILE_W/2, y);
		ctx.closePath();
		ctx.fillStyle = fillStyle;
		ctx.fill();
		ctx.strokeStyle = 'rgba(0,0,0,0.12)';
		ctx.stroke();
	}

	// Simple map: heights or floor color (for demo use a checker)
	const map = new Array(MAP_W).fill(0).map(()=> new Array(MAP_H).fill(0));
	for(let i=0;i<MAP_W;i++) for(let j=0;j<MAP_H;j++) map[i][j] = ((i+j)&1);

	// Main render loop
	let last = performance.now();
	function update(ts){
		const dt = Math.min(40, ts - last) / 1000; last = ts;

		// controls: WASD / arrows
		let dx=0, dy=0;
		if (keys['arrowup'] || keys['w']) dy -= 1;
		if (keys['arrowdown'] || keys['s']) dy += 1;
		if (keys['arrowleft'] || keys['a']) dx -= 1;
		if (keys['arrowright'] || keys['d']) dx += 1;

		if (dx !== 0 || dy !== 0){
			// Update direction based on input
			if (Math.abs(dx) > Math.abs(dy)){
				player.direction = dx > 0 ? 'right' : 'left';
			} else {
				player.direction = dy > 0 ? 'down' : 'up';
			}
			
			// Update animation frame
			player.animTime += dt;
			if (player.animTime >= player.animSpeed){
				player.animTime = 0;
				player.animFrame = (player.animFrame + 1) % frames[player.direction].length;
			}
			
			// normalize diagonal
			const len = Math.hypot(dx,dy) || 1;
			const step = player.speed * dt;
			// move in tile-coords: moving up should decrease y, right increase x
			player.x += (dx/len) * step;
			player.y += (dy/len) * step;
			// clamp inside map
			player.x = Math.max(0, Math.min(MAP_W-1, player.x));
			player.y = Math.max(0, Math.min(MAP_H-1, player.y));
		} else {
			// idle
			player.animTime = 0;
			player.animFrame = 0;
		}

		// camera ease to player
		cam.x += (player.x - cam.x) * Math.min(1, 6*dt);
		cam.y += (player.y - cam.y) * Math.min(1, 6*dt);

			render();
			requestAnimationFrame(update);
	}

	function render(){
		ctx.clearRect(0,0,canvas.width,canvas.height);

		// camera offset in screen pixels
		const camScreen = worldToScreen(cam.x, cam.y);
		const offsetX = canvas.width/2 - camScreen.x;
		const offsetY = canvas.height/4 - camScreen.y; // higher so character appears lower

		// draw ground tiles in painter's order (y then x)
		for(let i=0;i<MAP_W;i++){
			for(let j=0;j<MAP_H;j++){
				const pos = worldToScreen(i,j);
				const sx = pos.x + offsetX;
				const sy = pos.y + offsetY;
				const color = map[i][j] ? '#77a36c' : '#6a8f56';
				drawDiamond(sx, sy, color);
			}
		}

		// draw player (either sprite/programmatic model or the selected character image)
		const pScreen = worldToScreen(player.x, player.y);
		const px = pScreen.x + offsetX;
		const py = pScreen.y + offsetY;

		// draw rival above player (if loaded)
		if (typeof rivalImg !== 'undefined' && rivalImg && rivalLoaded){
			const rTileX = player.x;
			const rTileY = Math.max(0, player.y - 2);
			const rScreen = worldToScreen(rTileX, rTileY);
			const rpx = rScreen.x + offsetX;
			const rpy = rScreen.y + offsetY;
			// rival shadow
			ctx.beginPath(); ctx.ellipse(rpx, rpy + TILE_H/2 + 6, 18, 8, 0, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.22)'; ctx.fill();
			// rival image
			const rDrawW = FRAME_W * 3.0;
			const rDrawH = (rivalImg.naturalHeight / Math.max(1, rivalImg.naturalWidth)) * rDrawW;
			ctx.drawImage(rivalImg, rpx - rDrawW/2, rpy - rDrawH + (TILE_H/2), rDrawW, rDrawH);
		}

		// shadow (player)
		ctx.beginPath(); ctx.ellipse(px, py + TILE_H/2 + 6, 20, 9, 0, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.28)'; ctx.fill();

		if (useSprite && charLoaded){
			// draw the selected character image (full image, no animation frames)
			// scale to roughly the same visual size as sprite frames
			const drawW = FRAME_W * 3.5; // scale a bit larger for portraits
			const drawH = (charImg.naturalHeight / Math.max(1, charImg.naturalWidth)) * drawW;
			ctx.drawImage(charImg, px - drawW/2, py - drawH + (TILE_H/2), drawW, drawH);

		} else if (useSprite && spriteLoaded){
			// Draw individual sprite frame
			const dirFrames = frames[player.direction];
			const frame = dirFrames[player.animFrame];
			const drawW = FRAME_W * 2;  // scale 2x
			const drawH = FRAME_H * 2;
			ctx.drawImage(sprite, frame.x, frame.y, frame.w, frame.h, px - drawW/2, py - drawH + (TILE_H/2), drawW, drawH);
		} else {
			// Programmatic model: head, torso and swinging legs
			drawProgrammaticModel(px, py, player.direction, player.animTime, player.animFrame, playerMoving());
		}
	}

	// start loop only after selection/intro
	let gameStarted = false;
	function startGameLoop(){
		if (gameStarted) return;
		gameStarted = true;
		last = performance.now();
		requestAnimationFrame(update);
	}

	// Selection / intro logic
	const selectScreen = document.getElementById('selectScreen');
	const introScreen = document.getElementById('introScreen');
	const rivalPreview = document.getElementById('rivalPreview');
	const playerPreview = document.getElementById('playerPreview');

	const OPT_A = 'DBL15-06S.webp';
	const OPT_B = 'DBL-EVT-19S.webp';

	let rivalImg = null;
	let rivalLoaded = false;

	function beginMatch(playerSrc, rivalSrc, skipIntro){
		// persist choice and lock
		try{ localStorage.setItem('juegodbl_character', playerSrc); localStorage.setItem('juegodbl_locked', '1'); }catch(e){}

		// load images
		charImg = new Image(); charImg.src = playerSrc; charLoaded = false;
		charImg.onload = () => { charLoaded = true; };
		charImg.onerror = () => { charLoaded = false; console.warn('failed to load player image', playerSrc); };

		rivalImg = new Image(); rivalImg.src = rivalSrc; rivalLoaded = false;
		rivalImg.onload = () => { rivalLoaded = true; };
		rivalImg.onerror = () => { rivalLoaded = false; console.warn('failed to load rival image', rivalSrc); };

		// hide selector
		selectScreen.style.display = 'none';

		// show intro (rival above, player below)
		rivalPreview.innerHTML = '';
		playerPreview.innerHTML = '';
		const r = document.createElement('img'); r.src = rivalSrc; r.style.width = '200px'; r.style.height = 'auto'; r.style.borderRadius='8px';
		const p = document.createElement('img'); p.src = playerSrc; p.style.width = '200px'; p.style.height = 'auto'; p.style.borderRadius='8px';
		rivalPreview.appendChild(r);
		playerPreview.appendChild(p);
		introScreen.style.display = 'flex';

		if (skipIntro){
			introScreen.style.display = 'none';
			startGameLoop();
		} else {
			setTimeout(()=>{ introScreen.style.display = 'none'; startGameLoop(); }, 1800);
		}
	}

	// wire selection buttons
	document.getElementById('chooseA').addEventListener('click', ()=> beginMatch(OPT_A, OPT_B, false));
	document.getElementById('chooseB').addEventListener('click', ()=> beginMatch(OPT_B, OPT_A, false));

    // If already selected and locked, use it and start immediately
    const persisted = (function(){ try{ return localStorage.getItem('juegodbl_character'); }catch(e){return null;} })();
    const locked = (function(){ try{ return localStorage.getItem('juegodbl_locked') === '1'; }catch(e){return false;} })();
    if (persisted && locked){
        // determine rival as the other option if it matches known ones, otherwise fallback
        let rivalSrc = (persisted === OPT_A) ? OPT_B : OPT_A;
        beginMatch(persisted, rivalSrc, true);
    } else {
        // show selector
        selectScreen.style.display = 'flex';
    }

    // Reset button: clear localStorage and reload
    document.getElementById('resetGameBtn').addEventListener('click', ()=>{
        try{ 
            localStorage.removeItem('juegodbl_character');
            localStorage.removeItem('juegodbl_locked');
            localStorage.removeItem('juegodbl_selected');
        }catch(e){}
        location.reload();
    });	// helper: is player currently moving
	function playerMoving(){
		return (keys['arrowup']||keys['w']||keys['arrowdown']||keys['s']||keys['arrowleft']||keys['a']||keys['arrowright']||keys['d']);
	}

	// programmatic model drawer
	function drawProgrammaticModel(px, py, direction, animTime, animFrame, moving){
		// body params
		const scale = Math.min(2, Math.max(1.2, TILE_W/32));
		const headR = 8 * scale;
		const torsoH = 20 * scale;
		const torsoW = 14 * scale;
		const legLen = 18 * scale;

		// subtle bob while walking
		const t = performance.now() / 1000;
		const bob = moving ? Math.sin(t * 10) * 2 : 0;

		// compute leg swing angle
		const swing = moving ? Math.sin(t * 12) * 0.8 : 0;

		ctx.save();
		ctx.translate(px, py - (TILE_H/2)); // origin at feet center

		// draw torso
		ctx.fillStyle = '#3b6b3b';
		ctx.beginPath();
		ctx.ellipse(0, -torsoH/2 + bob, torsoW/1.2, torsoH/1.6, 0, 0, Math.PI*2);
		ctx.fill();

		// draw shield on left side (static)
		ctx.fillStyle = '#b0b0b0';
		ctx.beginPath();
		ctx.moveTo(-torsoW/2 - 6, -torsoH/2 + 4 + bob);
		ctx.lineTo(-torsoW/2 - 2, -torsoH/2 + 12 + bob);
		ctx.lineTo(-torsoW/2 + 8, -torsoH/2 + 4 + bob);
		ctx.closePath();
		ctx.fill();
		ctx.strokeStyle = '#6b6b6b'; ctx.stroke();

		// draw head
		ctx.fillStyle = '#ffd9b3';
		ctx.beginPath(); ctx.arc(0, -torsoH - headR + bob, headR, 0, Math.PI*2); ctx.fill();
		ctx.strokeStyle = '#7a5a3a'; ctx.stroke();

		// draw eyes
		ctx.fillStyle = '#000'; ctx.fillRect(-4, -torsoH - headR + bob -2, 2, 2); ctx.fillRect(2, -torsoH - headR + bob -2, 2, 2);

		// legs
		ctx.lineWidth = 4 * scale; ctx.lineCap = 'round'; ctx.strokeStyle = '#2f4f2f';
		// left leg
		ctx.beginPath();
		ctx.moveTo(-4*scale, 0 + bob);
		ctx.lineTo(-4*scale + Math.sin(swing) * legLen * 0.2, legLen + Math.cos(swing) * legLen * 0.4 + bob);
		ctx.stroke();
		// right leg
		ctx.beginPath();
		ctx.moveTo(4*scale, 0 + bob);
		ctx.lineTo(4*scale + Math.sin(-swing) * legLen * 0.2, legLen + Math.cos(-swing) * legLen * 0.4 + bob);
		ctx.stroke();

		// arm holding sword (right) and shield (left)
		ctx.lineWidth = 3 * scale; ctx.strokeStyle = '#6b4b2b';
		ctx.beginPath();
		ctx.moveTo(torsoW/2 -2, -torsoH/2 + 2 + bob);
		ctx.lineTo(torsoW/2 + 10, -torsoH/2 + 8 + bob);
		ctx.stroke();

		// simple sword tip
		ctx.beginPath(); ctx.moveTo(torsoW/2 + 10, -torsoH/2 + 8 + bob); ctx.lineTo(torsoW/2 + 14, -torsoH/2 + 6 + bob); ctx.stroke();

		ctx.restore();
	}

	// toggle: press M to switch between sprite and programmatic model
	let useSprite = true;
	window.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'm') useSprite = !useSprite; });

	</script>
</body>
</html>
</body>
</html>
